import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, w as validate_each_argument, b as validate_slots, e as element, t as text, f as space, g as claim_element, h as children, k as claim_text, l as detach_dev, m as claim_space, n as attr_dev, o as add_location, p as insert_dev, q as append_dev, r as set_data_dev, u as noop, I as destroy_each, v as validate_store, y as userStore, a as component_subscribe, R as voteStore, K as getContext, O as listen_dev, A as create_component, B as claim_component, C as mount_component, D as transition_in, E as transition_out, F as destroy_component, J as group_outros, H as check_outros, z as globals, M as set_input_value, N as run_all, P as prevent_default, T as null_to_empty, U as empty, V as onMount, W as binding_callbacks, X as stores$1, x as jamStore, Y as entryStore, Z as chatLogStore, _ as voteTokenStore, G as query_selector_all } from './client.61dd763a.js';
import { a as getUnix, g as getTimeLeft, u as unixify } from './time.8f7c612d.js';

/* src/components/Votes.svelte generated by Svelte v3.20.1 */

const file = "src/components/Votes.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[1] = list[i];
	return child_ctx;
}

// (7:2) {#each votes as vote}
function create_each_block(ctx) {
	let div1;
	let div0;
	let t0_value = /*vote*/ ctx[1].userId[0] + "";
	let t0;
	let t1;

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			t0 = text(t0_value);
			t1 = space();
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			t0 = claim_text(div0_nodes, t0_value);
			div0_nodes.forEach(detach_dev);
			t1 = claim_space(div1_nodes);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "vote-letter svelte-17jfuw1");
			add_location(div0, file, 8, 6, 156);
			attr_dev(div1, "class", "vote svelte-17jfuw1");
			add_location(div1, file, 7, 4, 130);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			append_dev(div0, t0);
			append_dev(div1, t1);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*votes*/ 1 && t0_value !== (t0_value = /*vote*/ ctx[1].userId[0] + "")) set_data_dev(t0, t0_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(7:2) {#each votes as vote}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let div;
	let each_value = /*votes*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "votes svelte-17jfuw1");
			add_location(div, file, 5, 0, 80);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*votes*/ 1) {
				each_value = /*votes*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { votes } = $$props;
	const writable_props = ["votes"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Votes> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Votes", $$slots, []);

	$$self.$set = $$props => {
		if ("votes" in $$props) $$invalidate(0, votes = $$props.votes);
	};

	$$self.$capture_state = () => ({ votes });

	$$self.$inject_state = $$props => {
		if ("votes" in $$props) $$invalidate(0, votes = $$props.votes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [votes];
}

class Votes extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { votes: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Votes",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*votes*/ ctx[0] === undefined && !("votes" in props)) {
			console.warn("<Votes> was created without expected prop 'votes'");
		}
	}

	get votes() {
		throw new Error("<Votes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set votes(value) {
		throw new Error("<Votes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Entry.svelte generated by Svelte v3.20.1 */
const file$1 = "src/components/Entry.svelte";

// (35:6) {#if canVote && entry.userId != userId}
function create_if_block_1(ctx) {
	let button;
	let t;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			t = text("vote!");
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true });
			var button_nodes = children(button);
			t = claim_text(button_nodes, "vote!");
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(button, "class", "button svelte-1uj1df8");
			add_location(button, file$1, 35, 8, 1217);
		},
		m: function mount(target, anchor, remount) {
			insert_dev(target, button, anchor);
			append_dev(button, t);
			if (remount) dispose();
			dispose = listen_dev(button, "click", /*handleVote*/ ctx[4], false, false, false);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(35:6) {#if canVote && entry.userId != userId}",
		ctx
	});

	return block;
}

// (39:4) {#if votes}
function create_if_block(ctx) {
	let current;

	const votes_1 = new Votes({
			props: { votes: /*votes*/ ctx[3] },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(votes_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(votes_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(votes_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const votes_1_changes = {};
			if (dirty & /*votes*/ 8) votes_1_changes.votes = /*votes*/ ctx[3];
			votes_1.$set(votes_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(votes_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(votes_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(votes_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(39:4) {#if votes}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let div2;
	let h3;
	let t0_value = /*entry*/ ctx[0].userId + "";
	let t0;
	let t1;
	let t2_value = /*entry*/ ctx[0].title + "";
	let t2;
	let t3;
	let div1;
	let div0;
	let a;
	let t4;
	let t5_value = /*entry*/ ctx[0].link.split("://")[1].split("/")[0] + "";
	let t5;
	let a_href_value;
	let t6;
	let t7;
	let current;
	let if_block0 = /*canVote*/ ctx[1] && /*entry*/ ctx[0].userId != /*userId*/ ctx[2] && create_if_block_1(ctx);
	let if_block1 = /*votes*/ ctx[3] && create_if_block(ctx);

	const block = {
		c: function create() {
			div2 = element("div");
			h3 = element("h3");
			t0 = text(t0_value);
			t1 = text(" - ");
			t2 = text(t2_value);
			t3 = space();
			div1 = element("div");
			div0 = element("div");
			a = element("a");
			t4 = text("Listen on ");
			t5 = text(t5_value);
			t6 = space();
			if (if_block0) if_block0.c();
			t7 = space();
			if (if_block1) if_block1.c();
			this.h();
		},
		l: function claim(nodes) {
			div2 = claim_element(nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			h3 = claim_element(div2_nodes, "H3", { class: true });
			var h3_nodes = children(h3);
			t0 = claim_text(h3_nodes, t0_value);
			t1 = claim_text(h3_nodes, " - ");
			t2 = claim_text(h3_nodes, t2_value);
			h3_nodes.forEach(detach_dev);
			t3 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			a = claim_element(div0_nodes, "A", { href: true, target: true });
			var a_nodes = children(a);
			t4 = claim_text(a_nodes, "Listen on ");
			t5 = claim_text(a_nodes, t5_value);
			a_nodes.forEach(detach_dev);
			t6 = claim_space(div0_nodes);
			if (if_block0) if_block0.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			t7 = claim_space(div1_nodes);
			if (if_block1) if_block1.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h3, "class", "header svelte-1uj1df8");
			add_location(h3, file$1, 28, 2, 930);
			attr_dev(a, "href", a_href_value = /*entry*/ ctx[0].link);
			attr_dev(a, "target", "_blank");
			add_location(a, file$1, 31, 6, 1049);
			attr_dev(div0, "class", "details-main svelte-1uj1df8");
			add_location(div0, file$1, 30, 4, 1015);
			attr_dev(div1, "class", "details svelte-1uj1df8");
			add_location(div1, file$1, 29, 2, 988);
			attr_dev(div2, "class", "entry");
			add_location(div2, file$1, 27, 0, 907);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, h3);
			append_dev(h3, t0);
			append_dev(h3, t1);
			append_dev(h3, t2);
			append_dev(div2, t3);
			append_dev(div2, div1);
			append_dev(div1, div0);
			append_dev(div0, a);
			append_dev(a, t4);
			append_dev(a, t5);
			append_dev(div0, t6);
			if (if_block0) if_block0.m(div0, null);
			append_dev(div1, t7);
			if (if_block1) if_block1.m(div1, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if ((!current || dirty & /*entry*/ 1) && t0_value !== (t0_value = /*entry*/ ctx[0].userId + "")) set_data_dev(t0, t0_value);
			if ((!current || dirty & /*entry*/ 1) && t2_value !== (t2_value = /*entry*/ ctx[0].title + "")) set_data_dev(t2, t2_value);
			if ((!current || dirty & /*entry*/ 1) && t5_value !== (t5_value = /*entry*/ ctx[0].link.split("://")[1].split("/")[0] + "")) set_data_dev(t5, t5_value);

			if (!current || dirty & /*entry*/ 1 && a_href_value !== (a_href_value = /*entry*/ ctx[0].link)) {
				attr_dev(a, "href", a_href_value);
			}

			if (/*canVote*/ ctx[1] && /*entry*/ ctx[0].userId != /*userId*/ ctx[2]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					if_block0.m(div0, null);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*votes*/ ctx[3]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
					transition_in(if_block1, 1);
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div1, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let $userStore;
	let $voteStore;
	validate_store(userStore, "userStore");
	component_subscribe($$self, userStore, $$value => $$invalidate(5, $userStore = $$value));
	validate_store(voteStore, "voteStore");
	component_subscribe($$self, voteStore, $$value => $$invalidate(6, $voteStore = $$value));
	const { getSocket } = getContext("socket");
	let { entry } = $$props;
	let { canVote } = $$props;

	// TODO: the only way a user can vote is if they submit an entry.
	// when a user submits an entry they get a "vote" token for that jam.
	// TODO: to show or not to show the user names as votes...
	// TODO: Find an easy way to figure out if a user has voted in this jam
	// idea - jam.voted = userId[] // can eventually be a query
	const handleVote = () => {
		const socket = getSocket();
		const payload = { userId, entryId: entry.id };
		socket.emit("addVote", payload);
	};

	const writable_props = ["entry", "canVote"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Entry> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Entry", $$slots, []);

	$$self.$set = $$props => {
		if ("entry" in $$props) $$invalidate(0, entry = $$props.entry);
		if ("canVote" in $$props) $$invalidate(1, canVote = $$props.canVote);
	};

	$$self.$capture_state = () => ({
		Votes,
		userStore,
		voteStore,
		getContext,
		getSocket,
		entry,
		canVote,
		handleVote,
		userId,
		$userStore,
		votes,
		$voteStore
	});

	$$self.$inject_state = $$props => {
		if ("entry" in $$props) $$invalidate(0, entry = $$props.entry);
		if ("canVote" in $$props) $$invalidate(1, canVote = $$props.canVote);
		if ("userId" in $$props) $$invalidate(2, userId = $$props.userId);
		if ("votes" in $$props) $$invalidate(3, votes = $$props.votes);
	};

	let userId;
	let votes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$userStore*/ 32) {
			 $$invalidate(2, userId = $userStore.id);
		}

		if ($$self.$$.dirty & /*$voteStore, entry*/ 65) {
			 $$invalidate(3, votes = $voteStore[entry.id]);
		}
	};

	return [entry, canVote, userId, votes, handleVote];
}

class Entry extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { entry: 0, canVote: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Entry",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*entry*/ ctx[0] === undefined && !("entry" in props)) {
			console.warn("<Entry> was created without expected prop 'entry'");
		}

		if (/*canVote*/ ctx[1] === undefined && !("canVote" in props)) {
			console.warn("<Entry> was created without expected prop 'canVote'");
		}
	}

	get entry() {
		throw new Error("<Entry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set entry(value) {
		throw new Error("<Entry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get canVote() {
		throw new Error("<Entry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set canVote(value) {
		throw new Error("<Entry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/EntryForm.svelte generated by Svelte v3.20.1 */

const { console: console_1 } = globals;
const file$2 = "src/components/EntryForm.svelte";

// (74:2) {#if error}
function create_if_block$1(ctx) {
	let div;
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text(/*error*/ ctx[3]);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t = claim_text(div_nodes, /*error*/ ctx[3]);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "error svelte-6bk5ow");
			add_location(div, file$2, 74, 4, 1487);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*error*/ 8) set_data_dev(t, /*error*/ ctx[3]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(74:2) {#if error}",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let form;
	let div0;
	let label0;
	let t0;
	let input0;
	let t1;
	let div1;
	let label1;
	let t2;
	let input1;
	let t3;
	let div2;
	let label2;
	let t4;
	let input2;
	let t5;
	let t6;
	let div3;
	let button;
	let t7;
	let dispose;
	let if_block = /*error*/ ctx[3] && create_if_block$1(ctx);

	const block = {
		c: function create() {
			form = element("form");
			div0 = element("div");
			label0 = element("label");
			t0 = text("Artist Name:\r\n      ");
			input0 = element("input");
			t1 = space();
			div1 = element("div");
			label1 = element("label");
			t2 = text("Entry Title:\r\n      ");
			input1 = element("input");
			t3 = space();
			div2 = element("div");
			label2 = element("label");
			t4 = text("Entry link:\r\n      ");
			input2 = element("input");
			t5 = space();
			if (if_block) if_block.c();
			t6 = space();
			div3 = element("div");
			button = element("button");
			t7 = text("Submit Entry");
			this.h();
		},
		l: function claim(nodes) {
			form = claim_element(nodes, "FORM", { class: true });
			var form_nodes = children(form);
			div0 = claim_element(form_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			label0 = claim_element(div0_nodes, "LABEL", {});
			var label0_nodes = children(label0);
			t0 = claim_text(label0_nodes, "Artist Name:\r\n      ");
			input0 = claim_element(label0_nodes, "INPUT", { type: true });
			label0_nodes.forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			t1 = claim_space(form_nodes);
			div1 = claim_element(form_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			label1 = claim_element(div1_nodes, "LABEL", {});
			var label1_nodes = children(label1);
			t2 = claim_text(label1_nodes, "Entry Title:\r\n      ");
			input1 = claim_element(label1_nodes, "INPUT", { type: true, placeholder: true });
			label1_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			t3 = claim_space(form_nodes);
			div2 = claim_element(form_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			label2 = claim_element(div2_nodes, "LABEL", {});
			var label2_nodes = children(label2);
			t4 = claim_text(label2_nodes, "Entry link:\r\n      ");
			input2 = claim_element(label2_nodes, "INPUT", { type: true, placeholder: true });
			label2_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			t5 = claim_space(form_nodes);
			if (if_block) if_block.l(form_nodes);
			t6 = claim_space(form_nodes);
			div3 = claim_element(form_nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			button = claim_element(div3_nodes, "BUTTON", { class: true });
			var button_nodes = children(button);
			t7 = claim_text(button_nodes, "Submit Entry");
			button_nodes.forEach(detach_dev);
			div3_nodes.forEach(detach_dev);
			form_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(input0, "type", "text");
			add_location(input0, file$2, 55, 6, 1062);
			add_location(label0, file$2, 53, 4, 1027);
			attr_dev(div0, "class", "svelte-6bk5ow");
			add_location(div0, file$2, 52, 2, 1016);
			attr_dev(input1, "type", "text");
			attr_dev(input1, "placeholder", "Creative Title");
			add_location(input1, file$2, 61, 6, 1177);
			add_location(label1, file$2, 59, 4, 1142);
			attr_dev(div1, "class", "svelte-6bk5ow");
			add_location(div1, file$2, 58, 2, 1131);
			attr_dev(input2, "type", "url");
			attr_dev(input2, "placeholder", "http://soundcloud.com/cool-artist/dank-beat");
			add_location(input2, file$2, 67, 6, 1319);
			add_location(label2, file$2, 65, 4, 1285);
			attr_dev(div2, "class", "svelte-6bk5ow");
			add_location(div2, file$2, 64, 2, 1274);
			attr_dev(button, "class", "svelte-6bk5ow");
			add_location(button, file$2, 77, 4, 1543);
			attr_dev(div3, "class", "svelte-6bk5ow");
			add_location(div3, file$2, 76, 2, 1532);
			attr_dev(form, "class", "entry-form svelte-6bk5ow");
			add_location(form, file$2, 51, 0, 947);
		},
		m: function mount(target, anchor, remount) {
			insert_dev(target, form, anchor);
			append_dev(form, div0);
			append_dev(div0, label0);
			append_dev(label0, t0);
			append_dev(label0, input0);
			set_input_value(input0, /*artist*/ ctx[1]);
			append_dev(form, t1);
			append_dev(form, div1);
			append_dev(div1, label1);
			append_dev(label1, t2);
			append_dev(label1, input1);
			set_input_value(input1, /*title*/ ctx[2]);
			append_dev(form, t3);
			append_dev(form, div2);
			append_dev(div2, label2);
			append_dev(label2, t4);
			append_dev(label2, input2);
			set_input_value(input2, /*link*/ ctx[0]);
			append_dev(form, t5);
			if (if_block) if_block.m(form, null);
			append_dev(form, t6);
			append_dev(form, div3);
			append_dev(div3, button);
			append_dev(button, t7);
			if (remount) run_all(dispose);

			dispose = [
				listen_dev(input0, "input", /*input0_input_handler*/ ctx[9]),
				listen_dev(input1, "input", /*input1_input_handler*/ ctx[10]),
				listen_dev(input2, "input", /*input2_input_handler*/ ctx[11]),
				listen_dev(form, "submit", prevent_default(/*handleSubmit*/ ctx[4]), false, true, false)
			];
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*artist*/ 2 && input0.value !== /*artist*/ ctx[1]) {
				set_input_value(input0, /*artist*/ ctx[1]);
			}

			if (dirty & /*title*/ 4 && input1.value !== /*title*/ ctx[2]) {
				set_input_value(input1, /*title*/ ctx[2]);
			}

			if (dirty & /*link*/ 1) {
				set_input_value(input2, /*link*/ ctx[0]);
			}

			if (/*error*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					if_block.m(form, t6);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(form);
			if (if_block) if_block.d();
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let $userStore;
	validate_store(userStore, "userStore");
	component_subscribe($$self, userStore, $$value => $$invalidate(7, $userStore = $$value));
	let { getSocket } = getContext("socket");
	let { jamId } = $$props;
	let link;
	let artist = $userStore.id;
	let title = "";
	let error = "";

	const handleSubmit = () => {
		if (!title) {
			$$invalidate(3, error = "you must supply a title");
			return;
		}

		if (!link) {
			$$invalidate(3, error = "you must supply a link!");
			return;
		}

		if (!artist) {
			$$invalidate(3, error = "needs an artist name!");
			return;
		}

		let entry = {
			link,
			artist,
			title,
			userId: user.id,
			jamId
		};

		$$invalidate(0, link = "");
		console.log("Adding Entry", entry);
		const socket = getSocket();
		socket.emit("addEntry", entry);
	};

	const writable_props = ["jamId"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<EntryForm> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("EntryForm", $$slots, []);

	function input0_input_handler() {
		artist = this.value;
		$$invalidate(1, artist);
	}

	function input1_input_handler() {
		title = this.value;
		$$invalidate(2, title);
	}

	function input2_input_handler() {
		link = this.value;
		$$invalidate(0, link);
	}

	$$self.$set = $$props => {
		if ("jamId" in $$props) $$invalidate(5, jamId = $$props.jamId);
	};

	$$self.$capture_state = () => ({
		userStore,
		getContext,
		getSocket,
		jamId,
		link,
		artist,
		title,
		error,
		handleSubmit,
		user,
		$userStore
	});

	$$self.$inject_state = $$props => {
		if ("getSocket" in $$props) getSocket = $$props.getSocket;
		if ("jamId" in $$props) $$invalidate(5, jamId = $$props.jamId);
		if ("link" in $$props) $$invalidate(0, link = $$props.link);
		if ("artist" in $$props) $$invalidate(1, artist = $$props.artist);
		if ("title" in $$props) $$invalidate(2, title = $$props.title);
		if ("error" in $$props) $$invalidate(3, error = $$props.error);
		if ("user" in $$props) user = $$props.user;
	};

	let user;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$userStore*/ 128) {
			 user = $userStore;
		}
	};

	return [
		link,
		artist,
		title,
		error,
		handleSubmit,
		jamId,
		user,
		$userStore,
		getSocket,
		input0_input_handler,
		input1_input_handler,
		input2_input_handler
	];
}

class EntryForm extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { jamId: 5 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "EntryForm",
			options,
			id: create_fragment$2.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*jamId*/ ctx[5] === undefined && !("jamId" in props)) {
			console_1.warn("<EntryForm> was created without expected prop 'jamId'");
		}
	}

	get jamId() {
		throw new Error("<EntryForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set jamId(value) {
		throw new Error("<EntryForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/ChatForm.svelte generated by Svelte v3.20.1 */
const file$3 = "src/components/ChatForm.svelte";

function create_fragment$3(ctx) {
	let form;
	let label;
	let input;
	let dispose;

	const block = {
		c: function create() {
			form = element("form");
			label = element("label");
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			form = claim_element(nodes, "FORM", {});
			var form_nodes = children(form);
			label = claim_element(form_nodes, "LABEL", {});
			var label_nodes = children(label);
			input = claim_element(label_nodes, "INPUT", { placeholder: true });
			label_nodes.forEach(detach_dev);
			form_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "placeholder", "enter chat message");
			add_location(input, file$3, 19, 4, 427);
			add_location(label, file$3, 18, 2, 414);
			add_location(form, file$3, 17, 0, 364);
		},
		m: function mount(target, anchor, remount) {
			insert_dev(target, form, anchor);
			append_dev(form, label);
			append_dev(label, input);
			set_input_value(input, /*text*/ ctx[0]);
			if (remount) run_all(dispose);

			dispose = [
				listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
				listen_dev(form, "submit", prevent_default(/*handleSubmit*/ ctx[1]), false, true, false)
			];
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*text*/ 1 && input.value !== /*text*/ ctx[0]) {
				set_input_value(input, /*text*/ ctx[0]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(form);
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let $userStore;
	validate_store(userStore, "userStore");
	component_subscribe($$self, userStore, $$value => $$invalidate(4, $userStore = $$value));
	let { jamId } = $$props;
	const { getSocket } = getContext("socket");
	let text = "";

	const handleSubmit = () => {
		const socket = getSocket();
		socket.emit("chat", { jamId, userId, text });
		$$invalidate(0, text = "");
	};

	const writable_props = ["jamId"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ChatForm> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("ChatForm", $$slots, []);

	function input_input_handler() {
		text = this.value;
		$$invalidate(0, text);
	}

	$$self.$set = $$props => {
		if ("jamId" in $$props) $$invalidate(2, jamId = $$props.jamId);
	};

	$$self.$capture_state = () => ({
		jamId,
		getContext,
		userStore,
		getSocket,
		text,
		handleSubmit,
		userId,
		$userStore
	});

	$$self.$inject_state = $$props => {
		if ("jamId" in $$props) $$invalidate(2, jamId = $$props.jamId);
		if ("text" in $$props) $$invalidate(0, text = $$props.text);
		if ("userId" in $$props) userId = $$props.userId;
	};

	let userId;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$userStore*/ 16) {
			 userId = $userStore.id;
		}
	};

	return [text, handleSubmit, jamId, userId, $userStore, getSocket, input_input_handler];
}

class ChatForm extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { jamId: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ChatForm",
			options,
			id: create_fragment$3.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*jamId*/ ctx[2] === undefined && !("jamId" in props)) {
			console.warn("<ChatForm> was created without expected prop 'jamId'");
		}
	}

	get jamId() {
		throw new Error("<ChatForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set jamId(value) {
		throw new Error("<ChatForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/ChatLog.svelte generated by Svelte v3.20.1 */

const file$4 = "src/components/ChatLog.svelte";

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[2] = list[i];
	return child_ctx;
}

// (6:0) {#each chat.slice(0, 10) as message}
function create_each_block$1(ctx) {
	let div2;
	let div0;
	let p;
	let t0_value = /*message*/ ctx[2].userId[0] + "";
	let t0;
	let t1;
	let div1;
	let t2_value = /*message*/ ctx[2].text + "";
	let t2;
	let t3;
	let div2_class_value;

	const block = {
		c: function create() {
			div2 = element("div");
			div0 = element("div");
			p = element("p");
			t0 = text(t0_value);
			t1 = space();
			div1 = element("div");
			t2 = text(t2_value);
			t3 = space();
			this.h();
		},
		l: function claim(nodes) {
			div2 = claim_element(nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div0 = claim_element(div2_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			p = claim_element(div0_nodes, "P", { class: true });
			var p_nodes = children(p);
			t0 = claim_text(p_nodes, t0_value);
			p_nodes.forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			t1 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			t2 = claim_text(div1_nodes, t2_value);
			div1_nodes.forEach(detach_dev);
			t3 = claim_space(div2_nodes);
			div2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(p, "class", "svelte-1t9f5mc");
			add_location(p, file$4, 8, 6, 208);
			attr_dev(div0, "class", "username svelte-1t9f5mc");
			add_location(div0, file$4, 7, 4, 178);
			attr_dev(div1, "class", "text svelte-1t9f5mc");
			add_location(div1, file$4, 10, 4, 252);

			attr_dev(div2, "class", div2_class_value = "" + (null_to_empty(`msg ${/*userId*/ ctx[1] === /*message*/ ctx[2].userId
			? "self"
			: "other"}`) + " svelte-1t9f5mc"));

			add_location(div2, file$4, 6, 2, 105);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div0);
			append_dev(div0, p);
			append_dev(p, t0);
			append_dev(div2, t1);
			append_dev(div2, div1);
			append_dev(div1, t2);
			append_dev(div2, t3);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*chat*/ 1 && t0_value !== (t0_value = /*message*/ ctx[2].userId[0] + "")) set_data_dev(t0, t0_value);
			if (dirty & /*chat*/ 1 && t2_value !== (t2_value = /*message*/ ctx[2].text + "")) set_data_dev(t2, t2_value);

			if (dirty & /*userId, chat*/ 3 && div2_class_value !== (div2_class_value = "" + (null_to_empty(`msg ${/*userId*/ ctx[1] === /*message*/ ctx[2].userId
			? "self"
			: "other"}`) + " svelte-1t9f5mc"))) {
				attr_dev(div2, "class", div2_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$1.name,
		type: "each",
		source: "(6:0) {#each chat.slice(0, 10) as message}",
		ctx
	});

	return block;
}

function create_fragment$4(ctx) {
	let each_1_anchor;
	let each_value = /*chat*/ ctx[0].slice(0, 10);
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*userId, chat*/ 3) {
				each_value = /*chat*/ ctx[0].slice(0, 10);
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	let { chat } = $$props;
	let { userId } = $$props;
	const writable_props = ["chat", "userId"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ChatLog> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("ChatLog", $$slots, []);

	$$self.$set = $$props => {
		if ("chat" in $$props) $$invalidate(0, chat = $$props.chat);
		if ("userId" in $$props) $$invalidate(1, userId = $$props.userId);
	};

	$$self.$capture_state = () => ({ chat, userId });

	$$self.$inject_state = $$props => {
		if ("chat" in $$props) $$invalidate(0, chat = $$props.chat);
		if ("userId" in $$props) $$invalidate(1, userId = $$props.userId);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [chat, userId];
}

class ChatLog extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, { chat: 0, userId: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ChatLog",
			options,
			id: create_fragment$4.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*chat*/ ctx[0] === undefined && !("chat" in props)) {
			console.warn("<ChatLog> was created without expected prop 'chat'");
		}

		if (/*userId*/ ctx[1] === undefined && !("userId" in props)) {
			console.warn("<ChatLog> was created without expected prop 'userId'");
		}
	}

	get chat() {
		throw new Error("<ChatLog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set chat(value) {
		throw new Error("<ChatLog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get userId() {
		throw new Error("<ChatLog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set userId(value) {
		throw new Error("<ChatLog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Clock.svelte generated by Svelte v3.20.1 */
const file$5 = "src/components/Clock.svelte";

function create_fragment$5(ctx) {
	let canvas_1;

	const block = {
		c: function create() {
			canvas_1 = element("canvas");
			this.h();
		},
		l: function claim(nodes) {
			canvas_1 = claim_element(nodes, "CANVAS", { width: true, height: true });
			children(canvas_1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(canvas_1, "width", width);
			attr_dev(canvas_1, "height", height);
			add_location(canvas_1, file$5, 79, 0, 1719);
		},
		m: function mount(target, anchor) {
			insert_dev(target, canvas_1, anchor);
			/*canvas_1_binding*/ ctx[8](canvas_1);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(canvas_1);
			/*canvas_1_binding*/ ctx[8](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const width = 150;
const height = 150;

function instance$5($$self, $$props, $$invalidate) {
	let { total } = $$props;
	let { startedAt } = $$props;
	let canvas;
	let ctx;

	const draw = () => {
		const u = remaining / total;
		const minute = remaining % 60 / 60;
		const second = remaining % 1;
		const w = width / 2;
		const h = height / 2;
		const hr = w * 0.8;
		const mr = w * 0.6;
		const sr = w * 0.4;
		const warning = u < 0.3;

		if (warning) {
			const flicker = Math.sin(u * Math.PI * 2 * total);

			if (flicker > 0) {
				document.title = "WARNING";
			} else {
				document.title = "Jam Ending";
			}
		}

		ctx.save();
		ctx.fillStyle = "#fff8";
		ctx.fillRect(0, 0, width, height);
		ctx.translate(w, h);
		ctx.rotate(Math.PI / 2);
		ctx.lineWidth = width / 10;

		// ctx.strokeStyle = `hsl()`;
		ctx.strokeStyle = warning ? "#f33" : "#333";

		ctx.beginPath();
		ctx.arc(0, 0, hr, 0, u * Math.PI * 2);
		ctx.stroke();

		// ctx.strokeStyle = `hsl()`;
		ctx.strokeStyle = warning ? "#955" : "#555";

		ctx.beginPath();
		ctx.arc(0, 0, mr, 0, minute * Math.PI * 2);
		ctx.stroke();

		// ctx.strokeStyle = `hsl()`;
		ctx.strokeStyle = warning ? "#4004" : "#0004";

		ctx.beginPath();
		ctx.arc(0, 0, sr, 0, second * Math.PI * 2);
		ctx.stroke();
		ctx.restore();
	};

	onMount(() => {
		ctx = canvas.getContext("2d");

		const interval = setInterval(
			() => {
				$$invalidate(4, current = new Date() / 1000);
				draw();
			},
			1000 / 15
		);

		return () => {
			clearInterval(interval);
		};
	});

	const writable_props = ["total", "startedAt"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Clock> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Clock", $$slots, []);

	function canvas_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			$$invalidate(0, canvas = $$value);
		});
	}

	$$self.$set = $$props => {
		if ("total" in $$props) $$invalidate(1, total = $$props.total);
		if ("startedAt" in $$props) $$invalidate(2, startedAt = $$props.startedAt);
	};

	$$self.$capture_state = () => ({
		onMount,
		width,
		height,
		total,
		startedAt,
		canvas,
		ctx,
		draw,
		current,
		started,
		remaining
	});

	$$self.$inject_state = $$props => {
		if ("total" in $$props) $$invalidate(1, total = $$props.total);
		if ("startedAt" in $$props) $$invalidate(2, startedAt = $$props.startedAt);
		if ("canvas" in $$props) $$invalidate(0, canvas = $$props.canvas);
		if ("ctx" in $$props) ctx = $$props.ctx;
		if ("current" in $$props) $$invalidate(4, current = $$props.current);
		if ("started" in $$props) $$invalidate(5, started = $$props.started);
		if ("remaining" in $$props) remaining = $$props.remaining;
	};

	let current;
	let started;
	let remaining;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*startedAt*/ 4) {
			 $$invalidate(5, started = new Date(startedAt) / 1000);
		}

		if ($$self.$$.dirty & /*started, current, total*/ 50) {
			 remaining = started - current + total;
		}
	};

	 $$invalidate(4, current = new Date() / 1000);

	return [
		canvas,
		total,
		startedAt,
		ctx,
		current,
		started,
		remaining,
		draw,
		canvas_1_binding
	];
}

class Clock extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, { total: 1, startedAt: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Clock",
			options,
			id: create_fragment$5.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*total*/ ctx[1] === undefined && !("total" in props)) {
			console.warn("<Clock> was created without expected prop 'total'");
		}

		if (/*startedAt*/ ctx[2] === undefined && !("startedAt" in props)) {
			console.warn("<Clock> was created without expected prop 'startedAt'");
		}
	}

	get total() {
		throw new Error("<Clock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set total(value) {
		throw new Error("<Clock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get startedAt() {
		throw new Error("<Clock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set startedAt(value) {
		throw new Error("<Clock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/jams/[id].svelte generated by Svelte v3.20.1 */

const { console: console_1$1 } = globals;
const file$6 = "src/routes/jams/[id].svelte";

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[18] = list[i];
	return child_ctx;
}

// (85:4) {:else}
function create_else_block_2(ctx) {
	let p0;
	let t0;
	let t1_value = /*jam*/ ctx[0].startedAt + "";
	let t1;
	let t2;
	let p1;
	let t3;
	let t4;
	let t5_value = Math.floor(/*timeLeft*/ ctx[4] % 60) + "";
	let t5;
	let t6;
	let t7;
	let current;
	let if_block = /*timeLeft*/ ctx[4] / 60 > 1 && create_if_block_6(ctx);

	const clock = new Clock({
			props: {
				total: /*jam*/ ctx[0].timeLimit,
				startedAt: /*jam*/ ctx[0].startedAt
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			p0 = element("p");
			t0 = text("Started At: ");
			t1 = text(t1_value);
			t2 = space();
			p1 = element("p");
			t3 = text("Time Left:\r\n        ");
			if (if_block) if_block.c();
			t4 = text("\r\n        , ");
			t5 = text(t5_value);
			t6 = text(" seconds");
			t7 = space();
			create_component(clock.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			p0 = claim_element(nodes, "P", {});
			var p0_nodes = children(p0);
			t0 = claim_text(p0_nodes, "Started At: ");
			t1 = claim_text(p0_nodes, t1_value);
			p0_nodes.forEach(detach_dev);
			t2 = claim_space(nodes);
			p1 = claim_element(nodes, "P", {});
			var p1_nodes = children(p1);
			t3 = claim_text(p1_nodes, "Time Left:\r\n        ");
			if (if_block) if_block.l(p1_nodes);
			t4 = claim_text(p1_nodes, "\r\n        , ");
			t5 = claim_text(p1_nodes, t5_value);
			t6 = claim_text(p1_nodes, " seconds");
			p1_nodes.forEach(detach_dev);
			t7 = claim_space(nodes);
			claim_component(clock.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			add_location(p0, file$6, 85, 6, 2374);
			add_location(p1, file$6, 86, 6, 2416);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p0, anchor);
			append_dev(p0, t0);
			append_dev(p0, t1);
			insert_dev(target, t2, anchor);
			insert_dev(target, p1, anchor);
			append_dev(p1, t3);
			if (if_block) if_block.m(p1, null);
			append_dev(p1, t4);
			append_dev(p1, t5);
			append_dev(p1, t6);
			insert_dev(target, t7, anchor);
			mount_component(clock, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty & /*jam*/ 1) && t1_value !== (t1_value = /*jam*/ ctx[0].startedAt + "")) set_data_dev(t1, t1_value);

			if (/*timeLeft*/ ctx[4] / 60 > 1) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_6(ctx);
					if_block.c();
					if_block.m(p1, t4);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if ((!current || dirty & /*timeLeft*/ 16) && t5_value !== (t5_value = Math.floor(/*timeLeft*/ ctx[4] % 60) + "")) set_data_dev(t5, t5_value);
			const clock_changes = {};
			if (dirty & /*jam*/ 1) clock_changes.total = /*jam*/ ctx[0].timeLimit;
			if (dirty & /*jam*/ 1) clock_changes.startedAt = /*jam*/ ctx[0].startedAt;
			clock.$set(clock_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(clock.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(clock.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p0);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(p1);
			if (if_block) if_block.d();
			if (detaching) detach_dev(t7);
			destroy_component(clock, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_2.name,
		type: "else",
		source: "(85:4) {:else}",
		ctx
	});

	return block;
}

// (83:27) 
function create_if_block_5(ctx) {
	let div;
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text("Time To Vote!");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			t = claim_text(div_nodes, "Time To Vote!");
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(div, file$6, 83, 6, 2329);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5.name,
		type: "if",
		source: "(83:27) ",
		ctx
	});

	return block;
}

// (81:4) {#if !jam.startedAt}
function create_if_block_4(ctx) {
	let button;
	let t;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			t = text("Start Jam!");
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t = claim_text(button_nodes, "Start Jam!");
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(button, file$6, 81, 6, 2242);
		},
		m: function mount(target, anchor, remount) {
			insert_dev(target, button, anchor);
			append_dev(button, t);
			if (remount) dispose();
			dispose = listen_dev(button, "click", /*handleStart*/ ctx[9], false, false, false);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(81:4) {#if !jam.startedAt}",
		ctx
	});

	return block;
}

// (89:8) {#if timeLeft / 60 > 1}
function create_if_block_6(ctx) {
	let t0_value = Math.floor(/*timeLeft*/ ctx[4] / 60) + "";
	let t0;
	let t1;

	const block = {
		c: function create() {
			t0 = text(t0_value);
			t1 = text(" minutes");
		},
		l: function claim(nodes) {
			t0 = claim_text(nodes, t0_value);
			t1 = claim_text(nodes, " minutes");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*timeLeft*/ 16 && t0_value !== (t0_value = Math.floor(/*timeLeft*/ ctx[4] / 60) + "")) set_data_dev(t0, t0_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_6.name,
		type: "if",
		source: "(89:8) {#if timeLeft / 60 > 1}",
		ctx
	});

	return block;
}

// (103:4) {#if jam.startedAt}
function create_if_block_2(ctx) {
	let div;
	let h2;
	let t0;
	let t1;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block_3, create_else_block_1];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*entries*/ ctx[1]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			div = element("div");
			h2 = element("h2");
			t0 = text("Entries");
			t1 = space();
			if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			h2 = claim_element(div_nodes, "H2", {});
			var h2_nodes = children(h2);
			t0 = claim_text(h2_nodes, "Entries");
			h2_nodes.forEach(detach_dev);
			t1 = claim_space(div_nodes);
			if_block.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h2, file$6, 104, 8, 2911);
			attr_dev(div, "class", "jam-entries");
			add_location(div, file$6, 103, 6, 2876);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, h2);
			append_dev(h2, t0);
			append_dev(div, t1);
			if_blocks[current_block_type_index].m(div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(div, null);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if_blocks[current_block_type_index].d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(103:4) {#if jam.startedAt}",
		ctx
	});

	return block;
}

// (110:8) {:else}
function create_else_block_1(ctx) {
	let p;
	let t0;
	let t1_value = (/*timeLeft*/ ctx[4] > 0 ? "...yet" : "!!") + "";
	let t1;

	const block = {
		c: function create() {
			p = element("p");
			t0 = text("This jam has no entries  ");
			t1 = text(t1_value);
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", {});
			var p_nodes = children(p);
			t0 = claim_text(p_nodes, "This jam has no entries  ");
			t1 = claim_text(p_nodes, t1_value);
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(p, file$6, 110, 10, 3075);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t0);
			append_dev(p, t1);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*timeLeft*/ 16 && t1_value !== (t1_value = (/*timeLeft*/ ctx[4] > 0 ? "...yet" : "!!") + "")) set_data_dev(t1, t1_value);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(110:8) {:else}",
		ctx
	});

	return block;
}

// (106:8) {#if entries}
function create_if_block_3(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*entries*/ ctx[1];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*canVote, entries*/ 10) {
				each_value = /*entries*/ ctx[1];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(106:8) {#if entries}",
		ctx
	});

	return block;
}

// (107:10) {#each entries as entry}
function create_each_block$2(ctx) {
	let current;

	const entry = new Entry({
			props: {
				canVote: /*canVote*/ ctx[3],
				entry: /*entry*/ ctx[18]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(entry.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(entry.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(entry, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const entry_changes = {};
			if (dirty & /*canVote*/ 8) entry_changes.canVote = /*canVote*/ ctx[3];
			if (dirty & /*entries*/ 2) entry_changes.entry = /*entry*/ ctx[18];
			entry.$set(entry_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(entry.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(entry.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(entry, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$2.name,
		type: "each",
		source: "(107:10) {#each entries as entry}",
		ctx
	});

	return block;
}

// (116:4) {#if timeLeft > -600 && jam.startedAt && !includesSelf(entries, userId)}
function create_if_block_1$1(ctx) {
	let current;

	const entryform = new EntryForm({
			props: { jamId: /*id*/ ctx[7] },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(entryform.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(entryform.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(entryform, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(entryform.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(entryform.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(entryform, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(116:4) {#if timeLeft > -600 && jam.startedAt && !includesSelf(entries, userId)}",
		ctx
	});

	return block;
}

// (125:8) {:else}
function create_else_block(ctx) {
	let div;
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text("All is quiet...");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			t = claim_text(div_nodes, "All is quiet...");
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(div, file$6, 125, 10, 3481);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(125:8) {:else}",
		ctx
	});

	return block;
}

// (123:8) {#if chat}
function create_if_block$2(ctx) {
	let current;

	const chatlog = new ChatLog({
			props: {
				chat: /*chat*/ ctx[5],
				userId: /*userId*/ ctx[2]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(chatlog.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(chatlog.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(chatlog, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const chatlog_changes = {};
			if (dirty & /*chat*/ 32) chatlog_changes.chat = /*chat*/ ctx[5];
			if (dirty & /*userId*/ 4) chatlog_changes.userId = /*userId*/ ctx[2];
			chatlog.$set(chatlog_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(chatlog.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(chatlog.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(chatlog, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(123:8) {#if chat}",
		ctx
	});

	return block;
}

function create_fragment$6(ctx) {
	let title_value;
	let t0;
	let header;
	let h1;
	let t1_value = /*jam*/ ctx[0].name + "";
	let t1;
	let t2;
	let p0;
	let t3;
	let t4_value = /*jam*/ ctx[0].userId + "";
	let t4;
	let t5;
	let div4;
	let div0;
	let h20;
	let t6;
	let t7;
	let p1;
	let t8;
	let t9_value = /*jam*/ ctx[0].description + "";
	let t9;
	let t10;
	let p2;
	let t11;
	let t12_value = Math.floor(/*jam*/ ctx[0].timeLimit / 60) + "";
	let t12;
	let t13;
	let t14;
	let current_block_type_index;
	let if_block0;
	let t15;
	let div3;
	let t16;
	let show_if = /*timeLeft*/ ctx[4] > -600 && /*jam*/ ctx[0].startedAt && !/*includesSelf*/ ctx[8](/*entries*/ ctx[1], /*userId*/ ctx[2]);
	let t17;
	let div2;
	let h21;
	let t18;
	let t19;
	let div1;
	let current_block_type_index_1;
	let if_block3;
	let t20;
	let current;
	document.title = title_value = "One Hour Beats - " + /*jam*/ ctx[0].name;
	const if_block_creators = [create_if_block_4, create_if_block_5, create_else_block_2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (!/*jam*/ ctx[0].startedAt) return 0;
		if (/*timeLeft*/ ctx[4] < 0) return 1;
		return 2;
	}

	current_block_type_index = select_block_type(ctx);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	let if_block1 = /*jam*/ ctx[0].startedAt && create_if_block_2(ctx);
	let if_block2 = show_if && create_if_block_1$1(ctx);
	const if_block_creators_1 = [create_if_block$2, create_else_block];
	const if_blocks_1 = [];

	function select_block_type_2(ctx, dirty) {
		if (/*chat*/ ctx[5]) return 0;
		return 1;
	}

	current_block_type_index_1 = select_block_type_2(ctx);
	if_block3 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);

	const chatform = new ChatForm({
			props: { jamId: /*id*/ ctx[7] },
			$$inline: true
		});

	const block = {
		c: function create() {
			t0 = space();
			header = element("header");
			h1 = element("h1");
			t1 = text(t1_value);
			t2 = space();
			p0 = element("p");
			t3 = text("Created by: ");
			t4 = text(t4_value);
			t5 = space();
			div4 = element("div");
			div0 = element("div");
			h20 = element("h2");
			t6 = text("Jam Info");
			t7 = space();
			p1 = element("p");
			t8 = text("Challenge Prompt: ");
			t9 = text(t9_value);
			t10 = space();
			p2 = element("p");
			t11 = text("Time Limit: ");
			t12 = text(t12_value);
			t13 = text(" minutes");
			t14 = space();
			if_block0.c();
			t15 = space();
			div3 = element("div");
			if (if_block1) if_block1.c();
			t16 = space();
			if (if_block2) if_block2.c();
			t17 = space();
			div2 = element("div");
			h21 = element("h2");
			t18 = text("Chatroom");
			t19 = space();
			div1 = element("div");
			if_block3.c();
			t20 = space();
			create_component(chatform.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-1u2jbni\"]", document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			header = claim_element(nodes, "HEADER", {});
			var header_nodes = children(header);
			h1 = claim_element(header_nodes, "H1", {});
			var h1_nodes = children(h1);
			t1 = claim_text(h1_nodes, t1_value);
			h1_nodes.forEach(detach_dev);
			t2 = claim_space(header_nodes);
			p0 = claim_element(header_nodes, "P", {});
			var p0_nodes = children(p0);
			t3 = claim_text(p0_nodes, "Created by: ");
			t4 = claim_text(p0_nodes, t4_value);
			p0_nodes.forEach(detach_dev);
			header_nodes.forEach(detach_dev);
			t5 = claim_space(nodes);
			div4 = claim_element(nodes, "DIV", { class: true });
			var div4_nodes = children(div4);
			div0 = claim_element(div4_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			h20 = claim_element(div0_nodes, "H2", {});
			var h20_nodes = children(h20);
			t6 = claim_text(h20_nodes, "Jam Info");
			h20_nodes.forEach(detach_dev);
			t7 = claim_space(div0_nodes);
			p1 = claim_element(div0_nodes, "P", {});
			var p1_nodes = children(p1);
			t8 = claim_text(p1_nodes, "Challenge Prompt: ");
			t9 = claim_text(p1_nodes, t9_value);
			p1_nodes.forEach(detach_dev);
			t10 = claim_space(div0_nodes);
			p2 = claim_element(div0_nodes, "P", {});
			var p2_nodes = children(p2);
			t11 = claim_text(p2_nodes, "Time Limit: ");
			t12 = claim_text(p2_nodes, t12_value);
			t13 = claim_text(p2_nodes, " minutes");
			p2_nodes.forEach(detach_dev);
			t14 = claim_space(div0_nodes);
			if_block0.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			t15 = claim_space(div4_nodes);
			div3 = claim_element(div4_nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			if (if_block1) if_block1.l(div3_nodes);
			t16 = claim_space(div3_nodes);
			if (if_block2) if_block2.l(div3_nodes);
			t17 = claim_space(div3_nodes);
			div2 = claim_element(div3_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			h21 = claim_element(div2_nodes, "H2", {});
			var h21_nodes = children(h21);
			t18 = claim_text(h21_nodes, "Chatroom");
			h21_nodes.forEach(detach_dev);
			t19 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			if_block3.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			t20 = claim_space(div2_nodes);
			claim_component(chatform.$$.fragment, div2_nodes);
			div2_nodes.forEach(detach_dev);
			div3_nodes.forEach(detach_dev);
			div4_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h1, file$6, 70, 2, 1935);
			add_location(p0, file$6, 71, 2, 1958);
			add_location(header, file$6, 69, 0, 1923);
			add_location(h20, file$6, 76, 4, 2076);
			add_location(p1, file$6, 77, 4, 2099);
			add_location(p2, file$6, 78, 4, 2147);
			attr_dev(div0, "class", "jam-room-info svelte-aotv29");
			add_location(div0, file$6, 75, 2, 2043);
			add_location(h21, file$6, 120, 6, 3346);
			attr_dev(div1, "class", "jam-chat svelte-aotv29");
			add_location(div1, file$6, 121, 6, 3371);
			attr_dev(div2, "class", "jam-chat-box svelte-aotv29");
			add_location(div2, file$6, 119, 4, 3312);
			attr_dev(div3, "class", "jam-room-right svelte-aotv29");
			add_location(div3, file$6, 101, 2, 2815);
			attr_dev(div4, "class", "jam-room page-content svelte-aotv29");
			add_location(div4, file$6, 74, 0, 2004);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, header, anchor);
			append_dev(header, h1);
			append_dev(h1, t1);
			append_dev(header, t2);
			append_dev(header, p0);
			append_dev(p0, t3);
			append_dev(p0, t4);
			insert_dev(target, t5, anchor);
			insert_dev(target, div4, anchor);
			append_dev(div4, div0);
			append_dev(div0, h20);
			append_dev(h20, t6);
			append_dev(div0, t7);
			append_dev(div0, p1);
			append_dev(p1, t8);
			append_dev(p1, t9);
			append_dev(div0, t10);
			append_dev(div0, p2);
			append_dev(p2, t11);
			append_dev(p2, t12);
			append_dev(p2, t13);
			append_dev(div0, t14);
			if_blocks[current_block_type_index].m(div0, null);
			append_dev(div4, t15);
			append_dev(div4, div3);
			if (if_block1) if_block1.m(div3, null);
			append_dev(div3, t16);
			if (if_block2) if_block2.m(div3, null);
			append_dev(div3, t17);
			append_dev(div3, div2);
			append_dev(div2, h21);
			append_dev(h21, t18);
			append_dev(div2, t19);
			append_dev(div2, div1);
			if_blocks_1[current_block_type_index_1].m(div1, null);
			append_dev(div2, t20);
			mount_component(chatform, div2, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if ((!current || dirty & /*jam*/ 1) && title_value !== (title_value = "One Hour Beats - " + /*jam*/ ctx[0].name)) {
				document.title = title_value;
			}

			if ((!current || dirty & /*jam*/ 1) && t1_value !== (t1_value = /*jam*/ ctx[0].name + "")) set_data_dev(t1, t1_value);
			if ((!current || dirty & /*jam*/ 1) && t4_value !== (t4_value = /*jam*/ ctx[0].userId + "")) set_data_dev(t4, t4_value);
			if ((!current || dirty & /*jam*/ 1) && t9_value !== (t9_value = /*jam*/ ctx[0].description + "")) set_data_dev(t9, t9_value);
			if ((!current || dirty & /*jam*/ 1) && t12_value !== (t12_value = Math.floor(/*jam*/ ctx[0].timeLimit / 60) + "")) set_data_dev(t12, t12_value);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				}

				transition_in(if_block0, 1);
				if_block0.m(div0, null);
			}

			if (/*jam*/ ctx[0].startedAt) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
					transition_in(if_block1, 1);
				} else {
					if_block1 = create_if_block_2(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div3, t16);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (dirty & /*timeLeft, jam, entries, userId*/ 23) show_if = /*timeLeft*/ ctx[4] > -600 && /*jam*/ ctx[0].startedAt && !/*includesSelf*/ ctx[8](/*entries*/ ctx[1], /*userId*/ ctx[2]);

			if (show_if) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
					transition_in(if_block2, 1);
				} else {
					if_block2 = create_if_block_1$1(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div3, t17);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			let previous_block_index_1 = current_block_type_index_1;
			current_block_type_index_1 = select_block_type_2(ctx);

			if (current_block_type_index_1 === previous_block_index_1) {
				if_blocks_1[current_block_type_index_1].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
					if_blocks_1[previous_block_index_1] = null;
				});

				check_outros();
				if_block3 = if_blocks_1[current_block_type_index_1];

				if (!if_block3) {
					if_block3 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
					if_block3.c();
				}

				transition_in(if_block3, 1);
				if_block3.m(div1, null);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(if_block2);
			transition_in(if_block3);
			transition_in(chatform.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(if_block2);
			transition_out(if_block3);
			transition_out(chatform.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(header);
			if (detaching) detach_dev(t5);
			if (detaching) detach_dev(div4);
			if_blocks[current_block_type_index].d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if_blocks_1[current_block_type_index_1].d();
			destroy_component(chatform);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	let $page;
	let $jamStore;
	let $entryStore;
	let $userStore;
	let $voteTokenStore;
	let $chatLogStore;
	validate_store(jamStore, "jamStore");
	component_subscribe($$self, jamStore, $$value => $$invalidate(11, $jamStore = $$value));
	validate_store(entryStore, "entryStore");
	component_subscribe($$self, entryStore, $$value => $$invalidate(12, $entryStore = $$value));
	validate_store(userStore, "userStore");
	component_subscribe($$self, userStore, $$value => $$invalidate(13, $userStore = $$value));
	validate_store(voteTokenStore, "voteTokenStore");
	component_subscribe($$self, voteTokenStore, $$value => $$invalidate(14, $voteTokenStore = $$value));
	validate_store(chatLogStore, "chatLogStore");
	component_subscribe($$self, chatLogStore, $$value => $$invalidate(16, $chatLogStore = $$value));
	const { page } = stores$1();
	validate_store(page, "page");
	component_subscribe($$self, page, value => $$invalidate(10, $page = value));
	const { getSocket } = getContext("socket");

	// if no entries by jam end, archive jam / delete
	// Add a socket for a room to add numbers
	let { params: { id } } = $page;

	onMount(() => {
		const socket = getSocket();

		const interval = setInterval(
			() => {
				$$invalidate(15, currentTime = getUnix());
			},
			1000
		);

		const jamId = $page.params.id;

		socket.on("chatUpdated", chatLog => {
			console.log("your chat has been updated", chatLog);
			chatLogStore.set(chatLog);
		});

		socket.emit("joinJamRoom", { jamId, userId });

		return () => {
			socket.emit("leaveJamRoom", { jamId, userId });
			clearInterval(interval);
		};
	});

	const includesSelf = (arr, userId) => {
		return arr && !!arr.find(a => a.userId === userId);
	};

	const handleStart = () => {
		const socket = getSocket();
		socket.emit("startJam", { id });
	};

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$1.warn(`<U5Bidu5D> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("U5Bidu5D", $$slots, []);

	$$self.$capture_state = () => ({
		Entry,
		EntryForm,
		ChatForm,
		ChatLog,
		Clock,
		jamStore,
		entryStore,
		userStore,
		chatLogStore,
		voteTokenStore,
		onMount,
		getContext,
		getUnix,
		getTimeLeft,
		unixify,
		stores: stores$1,
		page,
		getSocket,
		id,
		includesSelf,
		handleStart,
		$page,
		jam,
		$jamStore,
		entries,
		$entryStore,
		userId,
		$userStore,
		canVote,
		$voteTokenStore,
		currentTime,
		timeLeft,
		chat,
		$chatLogStore
	});

	$$self.$inject_state = $$props => {
		if ("id" in $$props) $$invalidate(7, id = $$props.id);
		if ("jam" in $$props) $$invalidate(0, jam = $$props.jam);
		if ("entries" in $$props) $$invalidate(1, entries = $$props.entries);
		if ("userId" in $$props) $$invalidate(2, userId = $$props.userId);
		if ("canVote" in $$props) $$invalidate(3, canVote = $$props.canVote);
		if ("currentTime" in $$props) $$invalidate(15, currentTime = $$props.currentTime);
		if ("timeLeft" in $$props) $$invalidate(4, timeLeft = $$props.timeLeft);
		if ("chat" in $$props) $$invalidate(5, chat = $$props.chat);
	};

	let jam;
	let entries;
	let userId;
	let canVote;
	let currentTime;
	let timeLeft;
	let chat;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$jamStore*/ 2048) {
			 $$invalidate(0, jam = $jamStore[id]);
		}

		if ($$self.$$.dirty & /*$entryStore*/ 4096) {
			 $$invalidate(1, entries = $entryStore[id]);
		}

		if ($$self.$$.dirty & /*$userStore*/ 8192) {
			 $$invalidate(2, userId = $userStore.id);
		}

		if ($$self.$$.dirty & /*$voteTokenStore, userId*/ 16388) {
			 $$invalidate(3, canVote = $voteTokenStore[userId] && $voteTokenStore[userId][id]);
		}

		if ($$self.$$.dirty & /*jam, currentTime*/ 32769) {
			 $$invalidate(4, timeLeft = unixify(jam.startedAt) + jam.timeLimit - currentTime);
		}

		if ($$self.$$.dirty & /*$chatLogStore*/ 65536) {
			 $$invalidate(5, chat = $chatLogStore[id]);
		}
	};

	 $$invalidate(15, currentTime = getUnix());

	return [
		jam,
		entries,
		userId,
		canVote,
		timeLeft,
		chat,
		page,
		id,
		includesSelf,
		handleStart
	];
}

class U5Bidu5D extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "U5Bidu5D",
			options,
			id: create_fragment$6.name
		});
	}
}

export default U5Bidu5D;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiW2lkXS41MWFiODQ3OC5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvVm90ZXMuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvRW50cnkuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvRW50cnlGb3JtLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL0NoYXRGb3JtLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL0NoYXRMb2cuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvQ2xvY2suc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9qYW1zL1tpZF0uc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+XHJcbiAgLy8gVE9ETzogRnVuIGFuaW1hdGlvbnMgb24gbG9hZCFcclxuICBleHBvcnQgbGV0IHZvdGVzO1xyXG48L3NjcmlwdD5cclxuXHJcbjxkaXYgY2xhc3M9XCJ2b3Rlc1wiPlxyXG4gIHsjZWFjaCB2b3RlcyBhcyB2b3RlfVxyXG4gICAgPGRpdiBjbGFzcz1cInZvdGVcIj5cclxuICAgICAgPGRpdiBjbGFzcz1cInZvdGUtbGV0dGVyXCI+e3ZvdGUudXNlcklkWzBdfTwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbiAgey9lYWNofVxyXG48L2Rpdj5cclxuXHJcbjxzdHlsZT5cclxuICAudm90ZXMge1xyXG4gICAgZGlzcGxheTogZmxleDtcclxuICB9XHJcblxyXG4gIC52b3RlIHtcclxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xyXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWhlYWRlci1mb250KTtcclxuXHJcbiAgICB3aWR0aDogMnJlbTtcclxuICAgIGhlaWdodDogMnJlbTtcclxuICAgIG1hcmdpbjogMC4xcmVtO1xyXG4gICAgYm94LXNoYWRvdzogMXB4IDFweCAjMDAwNTtcclxuICAgIGJvcmRlci1yYWRpdXM6IDFyZW07XHJcbiAgICBiYWNrZ3JvdW5kLWltYWdlOiBsaW5lYXItZ3JhZGllbnQoXHJcbiAgICAgIDExNWRlZyxcclxuICAgICAgdmFyKC0tYWNjZW50LWNvbG9yLWxpZ2h0KSxcclxuICAgICAgI2FmMTcwM1xyXG4gICAgKTtcclxuICAgIHRyYW5zaXRpb246IGFsbCBlYXNlLW91dCAwLjFzO1xyXG4gIH1cclxuXHJcbiAgLnZvdGU6aG92ZXIge1xyXG4gICAgbWFyZ2luLXRvcDogLTFweDtcclxuICAgIG1hcmdpbi1sZWZ0OiAtMXB4O1xyXG4gICAgYm94LXNoYWRvdzogMnB4IDJweCAycHggIzAwMDU7XHJcbiAgfVxyXG5cclxuICAudm90ZS1sZXR0ZXIge1xyXG4gICAgY3Vyc29yOiBkZWZhdWx0O1xyXG4gICAgZm9udC1zaXplOiAxNHB0O1xyXG4gICAgcGFkZGluZy10b3A6IDAuM3JlbTtcclxuICAgIHBhZGRpbmctcmlnaHQ6IDAuMXJlbTtcclxuICAgIHRleHQtc2hhZG93OiAycHggMnB4IDJweCAjMDAwYTtcclxuICAgIGNvbG9yOiAjZmZmO1xyXG4gICAgbWFyZ2luOiBhdXRvO1xyXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xyXG4gIH1cclxuPC9zdHlsZT5cclxuIiwiPHNjcmlwdD5cclxuICBpbXBvcnQgVm90ZXMgZnJvbSBcIi4uL2NvbXBvbmVudHMvVm90ZXMuc3ZlbHRlXCI7XHJcbiAgaW1wb3J0IHsgdXNlclN0b3JlLCB2b3RlU3RvcmUgfSBmcm9tIFwiLi4vc3RvcmVcIjtcclxuICBpbXBvcnQgeyBnZXRDb250ZXh0IH0gZnJvbSBcInN2ZWx0ZVwiO1xyXG5cclxuICBjb25zdCB7IGdldFNvY2tldCB9ID0gZ2V0Q29udGV4dChcInNvY2tldFwiKTtcclxuXHJcbiAgZXhwb3J0IGxldCBlbnRyeTtcclxuICBleHBvcnQgbGV0IGNhblZvdGU7XHJcbiAgJDogdXNlcklkID0gJHVzZXJTdG9yZS5pZDtcclxuICAkOiB2b3RlcyA9ICR2b3RlU3RvcmVbZW50cnkuaWRdO1xyXG5cclxuICAvLyBUT0RPOiB0aGUgb25seSB3YXkgYSB1c2VyIGNhbiB2b3RlIGlzIGlmIHRoZXkgc3VibWl0IGFuIGVudHJ5LlxyXG4gIC8vIHdoZW4gYSB1c2VyIHN1Ym1pdHMgYW4gZW50cnkgdGhleSBnZXQgYSBcInZvdGVcIiB0b2tlbiBmb3IgdGhhdCBqYW0uXHJcbiAgLy8gVE9ETzogdG8gc2hvdyBvciBub3QgdG8gc2hvdyB0aGUgdXNlciBuYW1lcyBhcyB2b3Rlcy4uLlxyXG4gIC8vIFRPRE86IEZpbmQgYW4gZWFzeSB3YXkgdG8gZmlndXJlIG91dCBpZiBhIHVzZXIgaGFzIHZvdGVkIGluIHRoaXMgamFtXHJcbiAgLy8gaWRlYSAtIGphbS52b3RlZCA9IHVzZXJJZFtdIC8vIGNhbiBldmVudHVhbGx5IGJlIGEgcXVlcnlcclxuXHJcbiAgY29uc3QgaGFuZGxlVm90ZSA9ICgpID0+IHtcclxuICAgIGNvbnN0IHNvY2tldCA9IGdldFNvY2tldCgpO1xyXG4gICAgY29uc3QgcGF5bG9hZCA9IHsgdXNlcklkLCBlbnRyeUlkOiBlbnRyeS5pZCB9O1xyXG4gICAgc29ja2V0LmVtaXQoXCJhZGRWb3RlXCIsIHBheWxvYWQpO1xyXG4gIH07XHJcbiAgLy8gdG9kbyBlbWJlZCBwbGF5YWJsYWVzXHJcbiAgLy8gdG9kbyBzb2NrZXQgb24gdm90ZXMgLSBhbmltYXRlIGluIHRodW1ic1xyXG48L3NjcmlwdD5cclxuXHJcbjxkaXYgY2xhc3M9XCJlbnRyeVwiPlxyXG4gIDxoMyBjbGFzcz1cImhlYWRlclwiPntlbnRyeS51c2VySWR9IC0ge2VudHJ5LnRpdGxlfTwvaDM+XHJcbiAgPGRpdiBjbGFzcz1cImRldGFpbHNcIj5cclxuICAgIDxkaXYgY2xhc3M9XCJkZXRhaWxzLW1haW5cIj5cclxuICAgICAgPGEgaHJlZj17ZW50cnkubGlua30gdGFyZ2V0PVwiX2JsYW5rXCI+XHJcbiAgICAgICAgTGlzdGVuIG9uIHtlbnRyeS5saW5rLnNwbGl0KCc6Ly8nKVsxXS5zcGxpdCgnLycpWzBdfVxyXG4gICAgICA8L2E+XHJcbiAgICAgIHsjaWYgY2FuVm90ZSAmJiBlbnRyeS51c2VySWQgIT0gdXNlcklkfVxyXG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZVZvdGV9IGNsYXNzPVwiYnV0dG9uXCI+dm90ZSE8L2J1dHRvbj5cclxuICAgICAgey9pZn1cclxuICAgIDwvZGl2PlxyXG4gICAgeyNpZiB2b3Rlc31cclxuICAgICAgPFZvdGVzIHt2b3Rlc30gLz5cclxuICAgIHsvaWZ9XHJcbiAgPC9kaXY+XHJcbjwvZGl2PlxyXG5cclxuPHN0eWxlPlxyXG4gIC5oZWFkZXIge1xyXG4gICAgYmFja2dyb3VuZDogI2NjYztcclxuICAgIGNvbG9yOiAjZmZmO1xyXG4gICAgcGFkZGluZzogMC43cmVtIDFyZW0gMC41cmVtO1xyXG4gICAgYm9yZGVyLXJhZGl1czogMC41cmVtIDAuNXJlbSAwIDA7XHJcbiAgICBtYXJnaW46IDA7XHJcbiAgfVxyXG4gIC5idXR0b24ge1xyXG4gICAgZm9udC1zaXplOiA4cHQ7XHJcbiAgICBib3JkZXItcmFkaXVzOiAwLjVyZW07XHJcbiAgICBwYWRkaW5nOiAwLjJyZW0gMXJlbSAwLjFyZW07XHJcbiAgfVxyXG4gIC5kZXRhaWxzIHtcclxuICAgIHBhZGRpbmc6IDFyZW0gMXJlbSAxcmVtO1xyXG4gICAgYm9yZGVyLXJhZGl1czogMCAwIDAuNXJlbSAwLjVyZW07XHJcbiAgICBib3JkZXI6IHNvbGlkICNjY2M7XHJcbiAgICBib3JkZXItd2lkdGg6IDBweCA0cHggMnB4IDFweDtcclxuICB9XHJcbiAgLmRldGFpbHMtbWFpbiB7XHJcbiAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xyXG4gIH1cclxuPC9zdHlsZT5cclxuIiwiPHNjcmlwdD5cclxuICBpbXBvcnQgeyB1c2VyU3RvcmUgfSBmcm9tIFwiLi4vc3RvcmVcIjtcclxuICBpbXBvcnQgeyBnZXRDb250ZXh0IH0gZnJvbSBcInN2ZWx0ZVwiO1xyXG4gIGxldCB7IGdldFNvY2tldCB9ID0gZ2V0Q29udGV4dChcInNvY2tldFwiKTtcclxuICBleHBvcnQgbGV0IGphbUlkO1xyXG4gIGxldCBsaW5rO1xyXG4gICQ6IHVzZXIgPSAkdXNlclN0b3JlO1xyXG4gIGxldCBhcnRpc3QgPSAkdXNlclN0b3JlLmlkO1xyXG4gIGxldCB0aXRsZSA9IFwiXCI7XHJcbiAgbGV0IGVycm9yID0gXCJcIjtcclxuXHJcbiAgY29uc3QgaGFuZGxlU3VibWl0ID0gKCkgPT4ge1xyXG4gICAgaWYgKCF0aXRsZSkge1xyXG4gICAgICBlcnJvciA9IFwieW91IG11c3Qgc3VwcGx5IGEgdGl0bGVcIjtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKCFsaW5rKSB7XHJcbiAgICAgIGVycm9yID0gXCJ5b3UgbXVzdCBzdXBwbHkgYSBsaW5rIVwiO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoIWFydGlzdCkge1xyXG4gICAgICBlcnJvciA9IFwibmVlZHMgYW4gYXJ0aXN0IG5hbWUhXCI7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGxldCBlbnRyeSA9IHtcclxuICAgICAgbGluayxcclxuICAgICAgYXJ0aXN0LFxyXG4gICAgICB0aXRsZSxcclxuICAgICAgdXNlcklkOiB1c2VyLmlkLFxyXG4gICAgICBqYW1JZFxyXG4gICAgfTtcclxuICAgIGxpbmsgPSBcIlwiO1xyXG4gICAgY29uc29sZS5sb2coXCJBZGRpbmcgRW50cnlcIiwgZW50cnkpO1xyXG4gICAgY29uc3Qgc29ja2V0ID0gZ2V0U29ja2V0KCk7XHJcbiAgICBzb2NrZXQuZW1pdChcImFkZEVudHJ5XCIsIGVudHJ5KTtcclxuICB9O1xyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZT5cclxuICAuZW50cnktZm9ybSB7XHJcbiAgfVxyXG5cclxuICAuZW50cnktZm9ybSBkaXYge1xyXG4gICAgbWFyZ2luLWJvdHRvbTogMXJlbTtcclxuICB9XHJcblxyXG4gIC5lbnRyeS1mb3JtIGJ1dHRvbiB7XHJcbiAgICBtYXJnaW4tcmlnaHQ6IDA7XHJcbiAgfVxyXG48L3N0eWxlPlxyXG5cclxuPGZvcm0gb246c3VibWl0fHByZXZlbnREZWZhdWx0PXtoYW5kbGVTdWJtaXR9IGNsYXNzPVwiZW50cnktZm9ybVwiPlxyXG4gIDxkaXY+XHJcbiAgICA8bGFiZWw+XHJcbiAgICAgIEFydGlzdCBOYW1lOlxyXG4gICAgICA8aW5wdXQgYmluZDp2YWx1ZT17YXJ0aXN0fSB0eXBlPVwidGV4dFwiIC8+XHJcbiAgICA8L2xhYmVsPlxyXG4gIDwvZGl2PlxyXG4gIDxkaXY+XHJcbiAgICA8bGFiZWw+XHJcbiAgICAgIEVudHJ5IFRpdGxlOlxyXG4gICAgICA8aW5wdXQgYmluZDp2YWx1ZT17dGl0bGV9IHR5cGU9XCJ0ZXh0XCIgcGxhY2Vob2xkZXI9XCJDcmVhdGl2ZSBUaXRsZVwiIC8+XHJcbiAgICA8L2xhYmVsPlxyXG4gIDwvZGl2PlxyXG4gIDxkaXY+XHJcbiAgICA8bGFiZWw+XHJcbiAgICAgIEVudHJ5IGxpbms6XHJcbiAgICAgIDxpbnB1dFxyXG4gICAgICAgIGJpbmQ6dmFsdWU9e2xpbmt9XHJcbiAgICAgICAgdHlwZT1cInVybFwiXHJcbiAgICAgICAgcGxhY2Vob2xkZXI9XCJodHRwOi8vc291bmRjbG91ZC5jb20vY29vbC1hcnRpc3QvZGFuay1iZWF0XCIgLz5cclxuICAgIDwvbGFiZWw+XHJcbiAgPC9kaXY+XHJcbiAgeyNpZiBlcnJvcn1cclxuICAgIDxkaXYgY2xhc3M9XCJlcnJvclwiPntlcnJvcn08L2Rpdj5cclxuICB7L2lmfVxyXG4gIDxkaXY+XHJcbiAgICA8YnV0dG9uPlN1Ym1pdCBFbnRyeTwvYnV0dG9uPlxyXG4gIDwvZGl2PlxyXG48L2Zvcm0+XHJcbiIsIjxzY3JpcHQ+XHJcbiAgZXhwb3J0IGxldCBqYW1JZDtcclxuICBpbXBvcnQgeyBnZXRDb250ZXh0IH0gZnJvbSBcInN2ZWx0ZVwiO1xyXG4gIGltcG9ydCB7IHVzZXJTdG9yZSB9IGZyb20gXCIuLi9zdG9yZVwiO1xyXG4gIGNvbnN0IHsgZ2V0U29ja2V0IH0gPSBnZXRDb250ZXh0KFwic29ja2V0XCIpO1xyXG5cclxuICAkOiB1c2VySWQgPSAkdXNlclN0b3JlLmlkO1xyXG4gIGxldCB0ZXh0ID0gXCJcIjtcclxuXHJcbiAgY29uc3QgaGFuZGxlU3VibWl0ID0gKCkgPT4ge1xyXG4gICAgY29uc3Qgc29ja2V0ID0gZ2V0U29ja2V0KCk7XHJcblxyXG4gICAgc29ja2V0LmVtaXQoXCJjaGF0XCIsIHsgamFtSWQsIHVzZXJJZCwgdGV4dCB9KTtcclxuICAgIHRleHQgPSBcIlwiO1xyXG4gIH07XHJcbjwvc2NyaXB0PlxyXG5cclxuPGZvcm0gb246c3VibWl0fHByZXZlbnREZWZhdWx0PXtoYW5kbGVTdWJtaXR9PlxyXG4gIDxsYWJlbD5cclxuICAgIDxpbnB1dCBiaW5kOnZhbHVlPXt0ZXh0fSBwbGFjZWhvbGRlcj1cImVudGVyIGNoYXQgbWVzc2FnZVwiIC8+XHJcbiAgPC9sYWJlbD5cclxuPC9mb3JtPlxyXG4iLCI8c2NyaXB0PlxyXG4gIGV4cG9ydCBsZXQgY2hhdDtcclxuICBleHBvcnQgbGV0IHVzZXJJZDtcclxuPC9zY3JpcHQ+XHJcblxyXG57I2VhY2ggY2hhdC5zbGljZSgwLCAxMCkgYXMgbWVzc2FnZX1cclxuICA8ZGl2IGNsYXNzPXtgbXNnICR7dXNlcklkID09PSBtZXNzYWdlLnVzZXJJZCA/ICdzZWxmJyA6ICdvdGhlcid9YH0+XHJcbiAgICA8ZGl2IGNsYXNzPVwidXNlcm5hbWVcIj5cclxuICAgICAgPHA+e21lc3NhZ2UudXNlcklkWzBdfTwvcD5cclxuICAgIDwvZGl2PlxyXG4gICAgPGRpdiBjbGFzcz1cInRleHRcIj57bWVzc2FnZS50ZXh0fTwvZGl2PlxyXG4gIDwvZGl2PlxyXG57L2VhY2h9XHJcblxyXG48c3R5bGU+XHJcbiAgLm1zZyB7XHJcbiAgICBtYXJnaW46IDAuMnJlbSBhdXRvIDAuNHJlbSAwO1xyXG4gIH1cclxuXHJcbiAgLnVzZXJuYW1lIHtcclxuICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICBhbGlnbi1jb250ZW50OiBjZW50ZXI7XHJcbiAgICB3aWR0aDogMnJlbTtcclxuICAgIGhlaWdodDogMnJlbTtcclxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcclxuICAgIGZvbnQtd2VpZ2h0OiBib2xkZXI7XHJcbiAgICBmb250LWZhbWlseTogdmFyKC0taGVhZGVyLWZvbnQpO1xyXG4gICAgdGV4dC1zaGFkb3c6IDFweCAxcHggIzAwMGE7XHJcbiAgICBjb2xvcjogI2ZmZjtcclxuICAgIGJhY2tncm91bmQtaW1hZ2U6IGxpbmVhci1ncmFkaWVudChcclxuICAgICAgMTE1ZGVnLFxyXG4gICAgICB2YXIoLS1hY2NlbnQtY29sb3ItbGlnaHQpLFxyXG4gICAgICAjYWYxNzAzXHJcbiAgICApO1xyXG4gICAgYm9yZGVyLXJhZGl1czogMXJlbTtcclxuICB9XHJcbiAgLnVzZXJuYW1lIHAge1xyXG4gICAgcGFkZGluZy10b3A6IDAuNXJlbTtcclxuICAgIG1hcmdpbjogYXV0bztcclxuICB9XHJcblxyXG4gIC5zZWxmIHtcclxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3ctcmV2ZXJzZTtcclxuICAgIG1hcmdpbi1yaWdodDogMDtcclxuICB9XHJcbiAgLnNlbGYgLnRleHQge1xyXG4gICAgYmFja2dyb3VuZDogdmFyKC0tYWNjZW50LWNvbG9yLWRhcmspO1xyXG4gICAgY29sb3I6ICNmZmY7XHJcbiAgICBtYXJnaW46IGF1dG8gMC41cmVtIDAuMXJlbTtcclxuICAgIHBhZGRpbmc6IDAuMnJlbSAxcmVtO1xyXG4gICAgYm9yZGVyLXJhZGl1czogMXJlbTtcclxuICB9XHJcbiAgLm1zZyB7XHJcbiAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgcGFkZGluZzogMC4xcmVtO1xyXG4gIH1cclxuICAub3RoZXIgLnRleHQge1xyXG4gICAgY29sb3I6ICM3Nzc7XHJcbiAgICBiYWNrZ3JvdW5kOiAjZGRkO1xyXG4gICAgbWFyZ2luOiBhdXRvIDAuNXJlbSAwLjFyZW07XHJcbiAgICBwYWRkaW5nOiAwLjJyZW0gMXJlbTtcclxuICAgIGJvcmRlci1yYWRpdXM6IDFyZW07XHJcbiAgfVxyXG48L3N0eWxlPlxyXG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuICBjb25zdCB3aWR0aCA9IDE1MDtcbiAgY29uc3QgaGVpZ2h0ID0gMTUwO1xuXG4gIGV4cG9ydCBsZXQgdG90YWw7XG4gIGV4cG9ydCBsZXQgc3RhcnRlZEF0O1xuICBsZXQgY2FudmFzO1xuICBsZXQgY3R4O1xuXG4gICQ6IGN1cnJlbnQgPSBuZXcgRGF0ZSgpIC8gMTAwMDtcbiAgJDogc3RhcnRlZCA9IG5ldyBEYXRlKHN0YXJ0ZWRBdCkgLyAxMDAwO1xuICAkOiByZW1haW5pbmcgPSBzdGFydGVkIC0gY3VycmVudCArIHRvdGFsO1xuXG4gIGNvbnN0IGRyYXcgPSAoKSA9PiB7XG4gICAgY29uc3QgdSA9IHJlbWFpbmluZyAvIHRvdGFsO1xuICAgIGNvbnN0IG1pbnV0ZSA9IChyZW1haW5pbmcgJSA2MCkgLyA2MDtcbiAgICBjb25zdCBzZWNvbmQgPSByZW1haW5pbmcgJSAxO1xuICAgIGNvbnN0IHcgPSB3aWR0aCAvIDI7XG4gICAgY29uc3QgaCA9IGhlaWdodCAvIDI7XG4gICAgY29uc3QgaHIgPSB3ICogMC44O1xuICAgIGNvbnN0IG1yID0gdyAqIDAuNjtcbiAgICBjb25zdCBzciA9IHcgKiAwLjQ7XG5cbiAgICBjb25zdCB3YXJuaW5nID0gdSA8IDAuMztcblxuICAgIGlmICh3YXJuaW5nKSB7XG4gICAgICBjb25zdCBmbGlja2VyID0gTWF0aC5zaW4odSAqIE1hdGguUEkgKiAyICogdG90YWwpO1xuICAgICAgaWYgKGZsaWNrZXIgPiAwKSB7XG4gICAgICAgIGRvY3VtZW50LnRpdGxlID0gXCJXQVJOSU5HXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb2N1bWVudC50aXRsZSA9IFwiSmFtIEVuZGluZ1wiO1xuICAgICAgfVxuICAgIH1cblxuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IFwiI2ZmZjhcIjtcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICBjdHgudHJhbnNsYXRlKHcsIGgpO1xuICAgIGN0eC5yb3RhdGUoTWF0aC5QSSAvIDIpO1xuXG4gICAgY3R4LmxpbmVXaWR0aCA9IHdpZHRoIC8gMTA7XG5cbiAgICAvLyBjdHguc3Ryb2tlU3R5bGUgPSBgaHNsKClgO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IHdhcm5pbmcgPyBcIiNmMzNcIiA6IFwiIzMzM1wiO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHguYXJjKDAsIDAsIGhyLCAwLCB1ICogTWF0aC5QSSAqIDIpO1xuICAgIGN0eC5zdHJva2UoKTtcblxuICAgIC8vIGN0eC5zdHJva2VTdHlsZSA9IGBoc2woKWA7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gd2FybmluZyA/IFwiIzk1NVwiIDogXCIjNTU1XCI7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5hcmMoMCwgMCwgbXIsIDAsIG1pbnV0ZSAqIE1hdGguUEkgKiAyKTtcbiAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAvLyBjdHguc3Ryb2tlU3R5bGUgPSBgaHNsKClgO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IHdhcm5pbmcgPyBcIiM0MDA0XCIgOiBcIiMwMDA0XCI7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5hcmMoMCwgMCwgc3IsIDAsIHNlY29uZCAqIE1hdGguUEkgKiAyKTtcbiAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9O1xuXG4gIG9uTW91bnQoKCkgPT4ge1xuICAgIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cbiAgICBjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGN1cnJlbnQgPSBuZXcgRGF0ZSgpIC8gMTAwMDtcbiAgICAgIGRyYXcoKTtcbiAgICB9LCAxMDAwIC8gMTUpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgIH07XG4gIH0pO1xuPC9zY3JpcHQ+XG5cbjxjYW52YXMgYmluZDp0aGlzPXtjYW52YXN9IHt3aWR0aH0ge2hlaWdodH0gLz5cblxuPCEtLSA8ZGl2PlxuICA8aDM+Y2xvY2s8L2gzPlxuICA8cD50b3RhbDoge3RvdGFsfTwvcD5cbiAgPHA+c3RhcnRlZDoge3N0YXJ0ZWR9PC9wPlxuICA8cD5jdXJyZW50OiB7Y3VycmVudH08L3A+XG4gIDxwPnJlbWFpbmluZzoge3JlbWFpbmluZ308L3A+XG4gIDxwPnBlcmNlbnQgcmVtYWluaW5nOiB7cmVtYWluaW5nIC8gdG90YWx9PC9wPlxuICA8cD5wZXJjZW50IGVsYXBzZWQ6IHsxIC0gcmVtYWluaW5nIC8gdG90YWx9PC9wPlxuPC9kaXY+IC0tPlxuIiwiPHNjcmlwdD5cclxuICBpbXBvcnQgRW50cnkgZnJvbSBcIi4uLy4uL2NvbXBvbmVudHMvRW50cnkuc3ZlbHRlXCI7XHJcbiAgaW1wb3J0IEVudHJ5Rm9ybSBmcm9tIFwiLi4vLi4vY29tcG9uZW50cy9FbnRyeUZvcm0uc3ZlbHRlXCI7XHJcbiAgaW1wb3J0IENoYXRGb3JtIGZyb20gXCIuLi8uLi9jb21wb25lbnRzL0NoYXRGb3JtLnN2ZWx0ZVwiO1xyXG4gIGltcG9ydCBDaGF0TG9nIGZyb20gXCIuLi8uLi9jb21wb25lbnRzL0NoYXRMb2cuc3ZlbHRlXCI7XHJcbiAgaW1wb3J0IENsb2NrIGZyb20gXCIuLi8uLi9jb21wb25lbnRzL0Nsb2NrLnN2ZWx0ZVwiO1xyXG5cclxuICBpbXBvcnQge1xyXG4gICAgamFtU3RvcmUsXHJcbiAgICBlbnRyeVN0b3JlLFxyXG4gICAgdXNlclN0b3JlLFxyXG4gICAgY2hhdExvZ1N0b3JlLFxyXG4gICAgdm90ZVRva2VuU3RvcmUsXHJcbiAgfSBmcm9tIFwiLi4vLi4vc3RvcmVcIjtcclxuXHJcbiAgaW1wb3J0IHsgb25Nb3VudCwgZ2V0Q29udGV4dCB9IGZyb20gXCJzdmVsdGVcIjtcclxuICBpbXBvcnQgeyBnZXRVbml4LCBnZXRUaW1lTGVmdCwgdW5peGlmeSB9IGZyb20gXCIuLi8uLi91dGlscy90aW1lXCI7XHJcbiAgaW1wb3J0IHsgc3RvcmVzIH0gZnJvbSBcIkBzYXBwZXIvYXBwXCI7XHJcbiAgY29uc3QgeyBwYWdlIH0gPSBzdG9yZXMoKTtcclxuICBjb25zdCB7IGdldFNvY2tldCB9ID0gZ2V0Q29udGV4dChcInNvY2tldFwiKTtcclxuICAvLyBpZiBubyBlbnRyaWVzIGJ5IGphbSBlbmQsIGFyY2hpdmUgamFtIC8gZGVsZXRlXHJcbiAgLy8gQWRkIGEgc29ja2V0IGZvciBhIHJvb20gdG8gYWRkIG51bWJlcnNcclxuXHJcbiAgbGV0IHtcclxuICAgIHBhcmFtczogeyBpZCB9LFxyXG4gIH0gPSAkcGFnZTtcclxuXHJcbiAgJDogamFtID0gJGphbVN0b3JlW2lkXTtcclxuICAkOiBlbnRyaWVzID0gJGVudHJ5U3RvcmVbaWRdO1xyXG4gICQ6IHVzZXJJZCA9ICR1c2VyU3RvcmUuaWQ7XHJcbiAgJDogY2FuVm90ZSA9ICR2b3RlVG9rZW5TdG9yZVt1c2VySWRdICYmICR2b3RlVG9rZW5TdG9yZVt1c2VySWRdW2lkXTtcclxuICAkOiBjdXJyZW50VGltZSA9IGdldFVuaXgoKTtcclxuICAkOiB0aW1lTGVmdCA9IHVuaXhpZnkoamFtLnN0YXJ0ZWRBdCkgKyBqYW0udGltZUxpbWl0IC0gY3VycmVudFRpbWU7XHJcbiAgJDogY2hhdCA9ICRjaGF0TG9nU3RvcmVbaWRdO1xyXG5cclxuICBvbk1vdW50KCgpID0+IHtcclxuICAgIGNvbnN0IHNvY2tldCA9IGdldFNvY2tldCgpO1xyXG4gICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XHJcbiAgICAgIGN1cnJlbnRUaW1lID0gZ2V0VW5peCgpO1xyXG4gICAgfSwgMTAwMCk7XHJcblxyXG4gICAgY29uc3QgamFtSWQgPSAkcGFnZS5wYXJhbXMuaWQ7XHJcblxyXG4gICAgc29ja2V0Lm9uKFwiY2hhdFVwZGF0ZWRcIiwgKGNoYXRMb2cpID0+IHtcclxuICAgICAgY29uc29sZS5sb2coXCJ5b3VyIGNoYXQgaGFzIGJlZW4gdXBkYXRlZFwiLCBjaGF0TG9nKTtcclxuICAgICAgY2hhdExvZ1N0b3JlLnNldChjaGF0TG9nKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHNvY2tldC5lbWl0KFwiam9pbkphbVJvb21cIiwgeyBqYW1JZCwgdXNlcklkIH0pO1xyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgc29ja2V0LmVtaXQoXCJsZWF2ZUphbVJvb21cIiwgeyBqYW1JZCwgdXNlcklkIH0pO1xyXG4gICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcclxuICAgIH07XHJcbiAgfSk7XHJcblxyXG4gIGNvbnN0IGluY2x1ZGVzU2VsZiA9IChhcnIsIHVzZXJJZCkgPT4ge1xyXG4gICAgcmV0dXJuIGFyciAmJiAhIWFyci5maW5kKChhKSA9PiBhLnVzZXJJZCA9PT0gdXNlcklkKTtcclxuICB9O1xyXG5cclxuICBjb25zdCBoYW5kbGVTdGFydCA9ICgpID0+IHtcclxuICAgIGNvbnN0IHNvY2tldCA9IGdldFNvY2tldCgpO1xyXG4gICAgc29ja2V0LmVtaXQoXCJzdGFydEphbVwiLCB7IGlkIH0pO1xyXG4gIH07XHJcbjwvc2NyaXB0PlxyXG5cclxuPHN2ZWx0ZTpoZWFkPlxyXG4gIDx0aXRsZT5PbmUgSG91ciBCZWF0cyAtIHtqYW0ubmFtZX08L3RpdGxlPlxyXG48L3N2ZWx0ZTpoZWFkPlxyXG5cclxuPGhlYWRlcj5cclxuICA8aDE+e2phbS5uYW1lfTwvaDE+XHJcbiAgPHA+Q3JlYXRlZCBieToge2phbS51c2VySWR9PC9wPlxyXG48L2hlYWRlcj5cclxuXHJcbjxkaXYgY2xhc3M9XCJqYW0tcm9vbSBwYWdlLWNvbnRlbnRcIj5cclxuICA8ZGl2IGNsYXNzPVwiamFtLXJvb20taW5mb1wiPlxyXG4gICAgPGgyPkphbSBJbmZvPC9oMj5cclxuICAgIDxwPkNoYWxsZW5nZSBQcm9tcHQ6IHtqYW0uZGVzY3JpcHRpb259PC9wPlxyXG4gICAgPHA+VGltZSBMaW1pdDoge01hdGguZmxvb3IoamFtLnRpbWVMaW1pdCAvIDYwKX0gbWludXRlczwvcD5cclxuXHJcbiAgICB7I2lmICFqYW0uc3RhcnRlZEF0fVxyXG4gICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVTdGFydH0+U3RhcnQgSmFtITwvYnV0dG9uPlxyXG4gICAgezplbHNlIGlmIHRpbWVMZWZ0IDwgMH1cclxuICAgICAgPGRpdj5UaW1lIFRvIFZvdGUhPC9kaXY+XHJcbiAgICB7OmVsc2V9XHJcbiAgICAgIDxwPlN0YXJ0ZWQgQXQ6IHtqYW0uc3RhcnRlZEF0fTwvcD5cclxuICAgICAgPHA+XHJcbiAgICAgICAgVGltZSBMZWZ0OlxyXG4gICAgICAgIHsjaWYgdGltZUxlZnQgLyA2MCA+IDF9e01hdGguZmxvb3IodGltZUxlZnQgLyA2MCl9IG1pbnV0ZXN7L2lmfVxyXG4gICAgICAgICwge01hdGguZmxvb3IodGltZUxlZnQgJSA2MCl9IHNlY29uZHNcclxuICAgICAgPC9wPlxyXG5cclxuICAgICAgPENsb2NrIHRvdGFsPXtqYW0udGltZUxpbWl0fSBzdGFydGVkQXQ9e2phbS5zdGFydGVkQXR9IC8+XHJcbiAgICB7L2lmfVxyXG5cclxuICAgIDwhLS0gPGgzPmRlYnVnPC9oMz5cclxuICAgIDxkaXY+e3VzZXJJZH0gY2FuIHZvdGU/OiB7Y2FuVm90ZX08L2Rpdj5cclxuICAgIDxkaXY+e3VzZXJJZH0gY2FuIHN1Ym1pdD86IHshaW5jbHVkZXNTZWxmKGVudHJpZXMsIHVzZXJJZCl9PC9kaXY+IC0tPlxyXG5cclxuICA8L2Rpdj5cclxuXHJcbiAgPGRpdiBjbGFzcz1cImphbS1yb29tLXJpZ2h0XCI+XHJcbiAgICB7I2lmIGphbS5zdGFydGVkQXR9XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJqYW0tZW50cmllc1wiPlxyXG4gICAgICAgIDxoMj5FbnRyaWVzPC9oMj5cclxuICAgICAgICB7I2lmIGVudHJpZXN9XHJcbiAgICAgICAgICB7I2VhY2ggZW50cmllcyBhcyBlbnRyeX1cclxuICAgICAgICAgICAgPEVudHJ5IHtjYW5Wb3RlfSB7ZW50cnl9IC8+XHJcbiAgICAgICAgICB7L2VhY2h9XHJcbiAgICAgICAgezplbHNlfVxyXG4gICAgICAgICAgPHA+VGhpcyBqYW0gaGFzIG5vIGVudHJpZXMg8J+YrSB7dGltZUxlZnQgPiAwID8gJy4uLnlldCcgOiAnISEnfTwvcD5cclxuICAgICAgICB7L2lmfVxyXG4gICAgICA8L2Rpdj5cclxuICAgIHsvaWZ9XHJcblxyXG4gICAgeyNpZiB0aW1lTGVmdCA+IC02MDAgJiYgamFtLnN0YXJ0ZWRBdCAmJiAhaW5jbHVkZXNTZWxmKGVudHJpZXMsIHVzZXJJZCl9XHJcbiAgICAgIDxFbnRyeUZvcm0gamFtSWQ9e2lkfSAvPlxyXG4gICAgey9pZn1cclxuXHJcbiAgICA8ZGl2IGNsYXNzPVwiamFtLWNoYXQtYm94XCI+XHJcbiAgICAgIDxoMj5DaGF0cm9vbTwvaDI+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJqYW0tY2hhdFwiPlxyXG4gICAgICAgIHsjaWYgY2hhdH1cclxuICAgICAgICAgIDxDaGF0TG9nIHtjaGF0fSB7dXNlcklkfSAvPlxyXG4gICAgICAgIHs6ZWxzZX1cclxuICAgICAgICAgIDxkaXY+QWxsIGlzIHF1aWV0Li4uPC9kaXY+XHJcbiAgICAgICAgey9pZn1cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDxDaGF0Rm9ybSBqYW1JZD17aWR9IC8+XHJcbiAgICA8L2Rpdj5cclxuICA8L2Rpdj5cclxuPC9kaXY+XHJcblxyXG48c3R5bGU+XHJcbiAgLmphbS1yb29tIHtcclxuICAgIHBhZGRpbmc6IDFyZW07XHJcbiAgICBkaXNwbGF5OiBmbGV4O1xyXG4gIH1cclxuICAuamFtLWNoYXQge1xyXG4gICAgZGlzcGxheTogZmxleDtcclxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW4tcmV2ZXJzZTtcclxuICAgIG1heC1oZWlnaHQ6IDI1MHB4O1xyXG4gICAgb3ZlcmZsb3cteTogc2Nyb2xsO1xyXG4gICAgLyogYm9yZGVyOiAxcHggI2FhYSBzb2xpZDsgKi9cclxuICAgIHBhZGRpbmc6IDAuMmVtIDAuNXJlbSAwO1xyXG4gICAgYm9yZGVyLXJhZGl1czogMXJlbTtcclxuICAgIG1hcmdpbjogMCAwIDAuNXJlbTtcclxuICB9XHJcbiAgLmphbS1jaGF0LWJveCB7XHJcbiAgICBwYWRkaW5nOiAxcmVtIDA7XHJcbiAgfVxyXG4gIC5qYW0tcm9vbS1pbmZvIHtcclxuICAgIGZsZXg6IDU7XHJcbiAgfVxyXG4gIC5qYW0tcm9vbS1yaWdodCB7XHJcbiAgICBmbGV4OiAzO1xyXG4gIH1cclxuPC9zdHlsZT5cclxuIl0sIm5hbWVzIjpbInN0b3JlcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7eUJBUWdDLEdBQUksSUFBQyxNQUFNLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dFQUFiLEdBQUksSUFBQyxNQUFNLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NEJBRnBDLEdBQUs7Ozs7Z0NBQVYsTUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MkJBQUMsR0FBSzs7OzsrQkFBVixNQUFJOzs7Ozs7Ozs7Ozs7Ozs7O29DQUFKLE1BQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BSkssS0FBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7d0RDaUNRLEdBQVU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBUGQsR0FBSyxJQUFDLE1BQU07OzswQkFBSyxHQUFLLElBQUMsS0FBSzs7Ozs7OzswQkFJL0IsR0FBSyxJQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUMsRUFBRSxLQUFLLENBQUMsR0FBRyxFQUFF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
